import contextlib
import json
import os
from unittest.mock import AsyncMock, Mock, patch

import aiohttp
from kubernetes_asyncio import client, config  # noqa: F401, used through reflection
from kubernetes_asyncio.client.api_client import ApiClient  # noqa: F401, used through reflection
from kubernetes_asyncio.client.models.v1_cron_job import V1CronJob
from kubernetes_asyncio.client.models.v1_cron_job_spec import V1CronJobSpec
from kubernetes_asyncio.client.models.v1_job_list import V1JobList
from kubernetes_asyncio.client.models.v1_job_template_spec import V1JobTemplateSpec
from kubernetes_asyncio.client.models.v1_object_meta import V1ObjectMeta
from kubernetes_asyncio.client.rest import ApiException
import pytest

from api_utils.exceptions import APIInternalError
from check_backends.k8s_backend import K8sBackend, load_config
from check_backends.check_backend import (
    AuthenticationObject,
    CheckId,
    CheckIdError,
    CheckTemplateId,
    CheckTemplateIdError,
    CronExpression,
    InCheckAttributes,
    InCheckMetadata,
)
from exceptions import CheckConnectionError

NAMESPACE: str = "resource-health"
TEMPLATES: str = "templates"
test_auth = "test-auth"
template_id = "simple_ping"
bad_template_id = "simply_ping"
template_args: dict[str, object] = {
    "health_check.name": "test-check",
    "endpoint": "www.example.com",
}
schedule = "* * * * *"

check_id_1 = "check_id_1"
check_id_2 = "check_id_2"
check_id_3 = "check_id_3"
check_id_4 = "check_id_4"
cronjob_1 = V1CronJob(
    metadata=V1ObjectMeta(
        name=check_id_1,
        annotations={
            "template_id": template_id,
            "template_args": json.dumps(template_args),
        },
    ),
    spec=V1CronJobSpec(
        schedule=str(schedule),
        job_template=V1JobTemplateSpec(),
    ),
)
cronjob_2 = V1CronJob(
    metadata=V1ObjectMeta(
        name=check_id_2,
        annotations={
            "template_id": template_id,
            "template_args": json.dumps(template_args),
        },
    ),
    spec=V1CronJobSpec(
        schedule=str(schedule),
        job_template=V1JobTemplateSpec(),
    ),
)
# Example of cronjob not generated by K8sBackend
cronjob_3 = V1CronJob(
    metadata=V1ObjectMeta(
        name=check_id_3,
    ),
    spec=V1CronJobSpec(
        schedule=str(schedule),
        job_template=V1JobTemplateSpec(),
    ),
)


@patch("test_k8s_backend.ApiClient", new_callable=AsyncMock)
async def test_aclose(mock_api_client: AsyncMock) -> None:
    try:
        k8s_backend = K8sBackend(
            template_dirs=[TEMPLATES],
            api_client=mock_api_client,
        )
    finally:
        await k8s_backend.aclose()


@pytest.mark.parametrize("kubernetes_service_host", ["mock_service_host", None])
@patch("test_k8s_backend.config.load_kube_config", new_callable=AsyncMock)
@patch("test_k8s_backend.config.load_incluster_config", new_callable=Mock)
async def test_load_config(
    mock_load_incluster_config: Mock,
    mock_load_kube_config: AsyncMock,
    kubernetes_service_host: str | None,
) -> None:
    with patch.dict(
        os.environ,
        {"KUBERNETES_SERVICE_HOST": kubernetes_service_host}
        if kubernetes_service_host
        else {},
        clear=True,
    ):
        await load_config()
        if kubernetes_service_host:
            mock_load_incluster_config.assert_called_once()
            mock_load_kube_config.assert_not_called()
        else:
            mock_load_incluster_config.assert_not_called()
            mock_load_kube_config.assert_called_once()


@pytest.mark.parametrize(
    "template_ids, expected",
    [
        (["simple_ping"], ["simple_ping"]),
        (["simply_ping"], []),
        (["default_k8s_template", "simply_ping"], ["default_k8s_template"]),
        (None, ["default_k8s_template", "simple_ping"]),
    ],
)
@patch("check_backends.k8s_backend.load_config", new_callable=AsyncMock)
@patch("test_k8s_backend.ApiClient", new_callable=AsyncMock)
@patch("test_k8s_backend.client.BatchV1Api")
async def test_get_check_templates(
    mock_batch_v1_api: Mock,
    mock_api_client: AsyncMock,
    mock_load_config: AsyncMock,
    template_ids: list[CheckTemplateId],
    expected: list[CheckTemplateId],
) -> None:
    k8s_backend = K8sBackend(
        template_dirs=[TEMPLATES],
        api_client=mock_api_client,
    )
    template_async_iterator = k8s_backend.get_check_templates(template_ids)
    template_list: list[CheckTemplateId] = []
    async for template in template_async_iterator:
        template_list.append(template.id)

    assert template_list == expected

    mock_load_config.assert_not_called()
    mock_batch_v1_api.assert_not_called()


@pytest.mark.parametrize(
    ("check_name,check_description,template_id,side_effect,expectation"),
    [
        (
            "Dummy name",
            "Dummy description",
            "simple_ping",
            None,
            contextlib.nullcontext(),
        ),
        (
            "Dummy name",
            "Dummy description",
            "simple_ping",
            ApiException(status=422),
            pytest.raises(APIInternalError),
        ),
        (
            "Dummy name",
            "Dummy description",
            "simple_ping",
            ApiException(),
            pytest.raises(ApiException),
        ),
        (
            "Dummy name",
            "Dummy description",
            "simple_ping",
            aiohttp.ClientConnectionError(),
            pytest.raises(CheckConnectionError),
        ),
        (
            "Dummy name",
            "Dummy description",
            "simple_ping",
            Exception(),
            pytest.raises(Exception),
        ),
        (
            "Dummy name",
            "Dummy description",
            "simply_ping",
            None,
            pytest.raises(CheckTemplateIdError),
        ),
    ],
)
@patch("check_backends.k8s_backend.load_config", new_callable=AsyncMock)
@patch("test_k8s_backend.ApiClient")
@patch("test_k8s_backend.client.BatchV1Api")
async def test_new_check(
    mock_batch_v1_api: Mock,
    mock_api_client: Mock,
    mock_load_config: AsyncMock,
    check_name: str,
    check_description: str,
    template_id: CheckTemplateId,
    side_effect: Exception | None,
    expectation: contextlib.AbstractContextManager,
) -> None:
    mock_batch_v1_api.return_value.create_namespaced_cron_job = AsyncMock(
        side_effect=side_effect,
        return_value=cronjob_1,
    )
    mock_api_client.return_value.__aenter__ = AsyncMock()

    k8s_backend = K8sBackend(
        template_dirs=[TEMPLATES],
        api_client=mock_api_client,
    )

    with expectation:
        result_check = await k8s_backend.create_check(
            AuthenticationObject(test_auth),
            InCheckAttributes(
                metadata=InCheckMetadata(
                    name=check_name,
                    description=check_description,
                    template_id=CheckTemplateId(template_id),
                    template_args=template_args,
                ),
                schedule=CronExpression(schedule),
            ),
        )

        # assert exc_info is None
        assert result_check.id == check_id_1
        assert result_check.attributes.metadata.name == check_name
        assert result_check.attributes.metadata.description == check_description
        assert result_check.attributes.metadata.template_id == template_id
        assert result_check.attributes.metadata.template_args == template_args
        assert result_check.attributes.schedule == CronExpression(schedule)

        mock_load_config.assert_called_once()
        mock_batch_v1_api.assert_called_once()
        mock_batch_v1_api.return_value.create_namespaced_cron_job.assert_called_once()
        call_kwargs = (
            mock_batch_v1_api.return_value.create_namespaced_cron_job.call_args.kwargs
        )
        assert call_kwargs["namespace"] == NAMESPACE


@pytest.mark.parametrize(
    ("side_effect, expectation"),
    [
        (None, contextlib.nullcontext()),
        (ApiException(status=404), pytest.raises(CheckIdError)),
        (ApiException(), pytest.raises(ApiException)),
        (aiohttp.ClientConnectionError(), pytest.raises(CheckConnectionError)),
        (Exception(), pytest.raises(Exception)),
    ],
)
@patch("check_backends.k8s_backend.load_config", new_callable=AsyncMock)
@patch("test_k8s_backend.ApiClient")
@patch("test_k8s_backend.client.BatchV1Api")
async def test_remove_check(
    mock_batch_v1_api: Mock,
    mock_api_client: Mock,
    mock_load_config: AsyncMock,
    side_effect: Exception | None,
    expectation: contextlib.AbstractContextManager,
) -> None:
    mock_batch_v1_api.return_value.delete_namespaced_cron_job = AsyncMock(
        side_effect=side_effect,
    )
    mock_api_client.return_value.__aenter__ = AsyncMock()

    k8s_backend = K8sBackend(
        template_dirs=[TEMPLATES],
        api_client=mock_api_client,
    )

    with expectation:
        await k8s_backend.remove_check(
            AuthenticationObject(test_auth),
            CheckId(check_id_1),
        )

        mock_load_config.assert_called_once()
        mock_batch_v1_api.assert_called_once()
        mock_batch_v1_api.return_value.delete_namespaced_cron_job.assert_called_once()
        call_kwargs = (
            mock_batch_v1_api.return_value.delete_namespaced_cron_job.call_args.kwargs
        )
        assert call_kwargs["name"] == check_id_1
        assert call_kwargs["namespace"] == NAMESPACE


@pytest.mark.parametrize(
    ("check_ids,side_effect,expectation,expected"),
    [
        (
            None,
            None,
            contextlib.nullcontext(),
            3,
        ),
        (
            [check_id_1],
            None,
            contextlib.nullcontext(),
            1,
        ),
        (
            [check_id_1, check_id_2],
            None,
            contextlib.nullcontext(),
            2,
        ),
        (
            [check_id_1, check_id_2, check_id_3],
            None,
            contextlib.nullcontext(),
            3,
        ),
        (
            [check_id_4],
            None,
            contextlib.nullcontext(),
            0,
        ),
        (
            [check_id_1, check_id_4],
            None,
            contextlib.nullcontext(),
            1,
        ),
        (
            [check_id_1, check_id_2, check_id_4],
            None,
            contextlib.nullcontext(),
            2,
        ),
        (
            None,
            ApiException,
            pytest.raises(ApiException),
            None,
        ),
        (
            None,
            aiohttp.ClientConnectionError,
            pytest.raises(CheckConnectionError),
            None,
        ),
        (
            None,
            Exception,
            pytest.raises(Exception),
            None,
        ),
    ],
)
@patch("check_backends.k8s_backend.load_config", new_callable=AsyncMock)
@patch("test_k8s_backend.ApiClient")
@patch("test_k8s_backend.client.BatchV1Api")
async def test_get_checks(
    mock_batch_v1_api: Mock,
    mock_api_client: Mock,
    mock_load_config: AsyncMock,
    check_ids: list[CheckId],
    side_effect: Exception | None,
    expectation: contextlib.AbstractContextManager,
    expected: int | None,
) -> None:
    mock_batch_v1_api.return_value.list_namespaced_cron_job = AsyncMock(
        side_effect=side_effect,
        return_value=V1JobList(items=[cronjob_1, cronjob_2, cronjob_3]),
    )
    mock_api_client.return_value.__aenter__ = AsyncMock()

    k8s_backend = K8sBackend(
        template_dirs=[TEMPLATES],
        api_client=mock_api_client,
    )

    with expectation:
        check_async_iterator = k8s_backend.get_checks(
            AuthenticationObject(test_auth),
            check_ids,
        )
        check_list = []
        async for check in check_async_iterator:
            check_list.append(check)

        assert len(check_list) == expected

        mock_load_config.assert_called_once()
        mock_batch_v1_api.assert_called_once()
        mock_batch_v1_api.return_value.list_namespaced_cron_job.assert_called_once()
        call_kwargs = (
            mock_batch_v1_api.return_value.list_namespaced_cron_job.call_args.kwargs
        )
        assert call_kwargs["namespace"] == NAMESPACE
