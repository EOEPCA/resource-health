import contextlib
import json
import os
from typing import Callable, NewType
from unittest.mock import AsyncMock, Mock, patch

import aiohttp
from kubernetes_asyncio import client, config  # noqa: F401, used through reflection
from kubernetes_asyncio.client.models.v1_cron_job import V1CronJob
from kubernetes_asyncio.client.models.v1_cron_job_spec import V1CronJobSpec
from kubernetes_asyncio.client.models.v1_job_list import V1JobList
from kubernetes_asyncio.client.models.v1_job_template_spec import V1JobTemplateSpec
from kubernetes_asyncio.client.models.v1_object_meta import V1ObjectMeta
from kubernetes_asyncio.client.rest import ApiException
import pytest

from eoepca_api_utils.exceptions import APIInternalError
from check_backends.k8s_backend import K8sBackend
from check_backends.check_backend import (
    CheckId,
    CheckIdError,
    CheckTemplateId,
    CheckTemplateIdError,
    CronExpression,
    InCheckAttributes,
    InCheckMetadata,
)
from check_hooks.hook_utils import k8s_config
from exceptions import CheckConnectionError

AuthenticationObject = NewType("AuthenticationObject", dict[str, str])

NAMESPACE: str = "resource-health"
TEMPLATES: list[str] = ["example_k8s_templates"]
test_auth = {"username": "Test User"}
check_name = "Dummy name"
check_description = "Dummy description"
template_id = "simple_ping"
bad_template_id = "simply_ping"
template_args: dict[str, object] = {
    "endpoint": "www.example.com",
    "expected_status_code": 200,
}
schedule = "* * * * *"

check_id_1 = "check_id_1"
check_id_2 = "check_id_2"
check_id_3 = "check_id_3"
check_id_4 = "check_id_4"
check_uuid_1 = "check_uuid_1"
cronjob_1 = V1CronJob(
    metadata=V1ObjectMeta(
        name=check_id_1,
        uid=check_uuid_1,
        annotations={
            "name": check_name,
            "description": check_description,
            "template_id": template_id,
            "template_args": json.dumps(template_args),
        },
    ),
    spec=V1CronJobSpec(
        schedule=str(schedule),
        job_template=V1JobTemplateSpec(),
    ),
)
cronjob_2 = V1CronJob(
    metadata=V1ObjectMeta(
        name=check_id_2,
        annotations={
            "name": check_name,
            "description": check_description,
            "template_id": template_id,
            "template_args": json.dumps(template_args),
        },
    ),
    spec=V1CronJobSpec(
        schedule=str(schedule),
        job_template=V1JobTemplateSpec(),
    ),
)
# Example of cronjob not generated by K8sBackend
cronjob_3 = V1CronJob(
    metadata=V1ObjectMeta(
        name=check_id_3,
    ),
    spec=V1CronJobSpec(
        schedule=str(schedule),
        job_template=V1JobTemplateSpec(),
    ),
)


@pytest.fixture(autouse=True)
def setup_template_env() -> None:
    # Needed for telemetry_access_template to initialize without raising exceptions
    os.environ["OPEN_ID_CONNECT_URL"] = "DYMMY_TEST_URL"


@pytest.fixture
def mock_api_client() -> Mock:
    api_client = Mock()
    api_client.return_value.__aenter__ = AsyncMock(return_value=None)
    api_client.return_value.__aexit__ = AsyncMock(return_value=None)
    return api_client


def make_hooks(api_client) -> dict[str, list[Callable]]:
    async def get_client(token):
        return api_client

    return {
        "on_auth": [
            lambda auth: auth if auth == AuthenticationObject(test_auth) else None
        ],
        "get_k8s_config": [lambda _: k8s_config()],
        "get_k8s_namespace": [lambda _: NAMESPACE],
    }


async def test_aclose(mock_api_client) -> None:
    try:
        k8s_backend = K8sBackend[AuthenticationObject](
            template_dirs=TEMPLATES,
            hooks=make_hooks(mock_api_client),
        )
    finally:
        await k8s_backend.aclose()


# @pytest.mark.parametrize("kubernetes_service_host", ["mock_service_host", None])
# @patch("test_k8s_backend.config.load_kube_config", new_callable=AsyncMock)
# @patch("test_k8s_backend.config.load_incluster_config", new_callable=Mock)
# async def test_load_config(
#     mock_load_incluster_config: Mock,
#     mock_load_kube_config: AsyncMock,
#     kubernetes_service_host: str | None,
# ) -> None:
#     with patch.dict(
#         os.environ,
#         {"KUBERNETES_SERVICE_HOST": kubernetes_service_host}
#         if kubernetes_service_host
#         else {},
#         clear=True,
#     ):
#         await load_config()
#         if kubernetes_service_host:
#             mock_load_incluster_config.assert_called_once()
#             mock_load_kube_config.assert_not_called()
#         else:
#             mock_load_incluster_config.assert_not_called()
#             mock_load_kube_config.assert_called_once()


@pytest.mark.parametrize(
    "template_ids, expected",
    [
        (["simple_ping"], ["simple_ping"]),
        (
            None,
            [
                "generic_script_template",
                "simple_ping",
                "telemetry_access_template",
                "collection_check",
            ],
        ),
    ],
)
@patch("test_k8s_backend.client.BatchV1Api")
async def test_get_check_templates(
    mock_batch_v1_api: Mock,
    template_ids: list[CheckTemplateId],
    expected: list[CheckTemplateId],
) -> None:
    mock_api_client = AsyncMock()
    k8s_backend = K8sBackend[AuthenticationObject](
        template_dirs=TEMPLATES,
        hooks=make_hooks(mock_api_client),
    )
    template_async_iterator = k8s_backend.get_check_templates(
        AuthenticationObject(test_auth), template_ids
    )
    template_list: list[CheckTemplateId] = []
    async for template in template_async_iterator:
        template_list.append(template.id)

    assert sorted(template_list) == sorted(expected)

    mock_batch_v1_api.assert_not_called()


@pytest.mark.parametrize(
    "template_ids, expected_error_id",
    [
        (["simply_ping"], "simply_ping"),
        (["generic_script_template", "simply_ping"], "simply_ping"),
    ],
)
@patch("test_k8s_backend.client.BatchV1Api")
async def test_get_check_templates_raises(
    mock_batch_v1_api: Mock,
    template_ids: list[CheckTemplateId],
    expected_error_id: CheckTemplateId,
) -> None:
    mock_api_client = AsyncMock()
    k8s_backend = K8sBackend[AuthenticationObject](
        template_dirs=TEMPLATES,
        hooks=make_hooks(mock_api_client),
    )
    template_async_iterator = k8s_backend.get_check_templates(
        AuthenticationObject(test_auth), template_ids
    )
    template_list: list[CheckTemplateId] = []
    with pytest.raises(KeyError) as error_info:
        async for template in template_async_iterator:
            template_list.append(template.id)

    assert expected_error_id in repr(error_info.value)

    mock_batch_v1_api.assert_not_called()


@pytest.mark.parametrize(
    ("template_id,side_effect,expectation"),
    [
        (
            "simple_ping",
            None,
            contextlib.nullcontext(),
        ),
        (
            "simple_ping",
            ApiException(status=422),
            pytest.raises(APIInternalError),
        ),
        (
            "simple_ping",
            ApiException(),
            pytest.raises(ApiException),
        ),
        (
            "simple_ping",
            aiohttp.ClientConnectionError(),
            pytest.raises(CheckConnectionError),
        ),
        (
            "simple_ping",
            Exception(),
            pytest.raises(Exception),
        ),
        (
            "simply_ping",
            None,
            pytest.raises(CheckTemplateIdError),
        ),
    ],
)
@patch("test_k8s_backend.client.BatchV1Api")
async def test_create_check(
    mock_batch_v1_api: Mock,
    template_id: CheckTemplateId,
    side_effect: Exception | None,
    expectation: contextlib.AbstractContextManager,
    mock_api_client: Mock,
) -> None:
    mock_batch_v1_api.return_value.create_namespaced_cron_job = AsyncMock(
        side_effect=side_effect,
        return_value=cronjob_1,
    )

    k8s_backend = K8sBackend[AuthenticationObject](
        template_dirs=TEMPLATES,
        hooks=make_hooks(mock_api_client),
    )

    with expectation:
        result_check = await k8s_backend.create_check(
            AuthenticationObject(test_auth),
            InCheckAttributes(
                metadata=InCheckMetadata(
                    name=check_name,
                    description=check_description,
                    template_id=CheckTemplateId(template_id),
                    template_args=template_args,
                ),
                schedule=CronExpression(schedule),
            ),
        )

        assert result_check.id == check_id_1
        assert result_check.attributes.metadata.name == check_name
        assert result_check.attributes.metadata.description == check_description
        assert result_check.attributes.metadata.template_id == template_id
        assert result_check.attributes.metadata.template_args == template_args
        assert result_check.attributes.schedule == CronExpression(schedule)

        mock_batch_v1_api.assert_called_once()
        mock_batch_v1_api.return_value.create_namespaced_cron_job.assert_called_once()
        call_kwargs = (
            mock_batch_v1_api.return_value.create_namespaced_cron_job.call_args.kwargs
        )
        assert call_kwargs["namespace"] == NAMESPACE
        assert call_kwargs["body"].metadata.annotations["name"] == check_name
        assert (
            call_kwargs["body"].metadata.annotations["description"] == check_description
        )
        assert call_kwargs["body"].metadata.annotations["template_id"] == template_id
        assert (
            json.loads(call_kwargs["body"].metadata.annotations["template_args"])
            == template_args
        )


@pytest.mark.parametrize(
    ("side_effect, expectation"),
    [
        (None, contextlib.nullcontext()),
        (ApiException(status=404), pytest.raises(CheckIdError)),
        (ApiException(), pytest.raises(ApiException)),
        (aiohttp.ClientConnectionError(), pytest.raises(CheckConnectionError)),
        (Exception(), pytest.raises(Exception)),
    ],
)
@patch("test_k8s_backend.client.BatchV1Api")
async def test_remove_check(
    mock_batch_v1_api: Mock,
    side_effect: Exception | None,
    expectation: contextlib.AbstractContextManager,
    mock_api_client: Mock,
) -> None:
    mock_batch_v1_api.return_value.read_namespaced_cron_job = AsyncMock(
        return_value=cronjob_1,
    )
    mock_batch_v1_api.return_value.delete_namespaced_cron_job = AsyncMock(
        side_effect=side_effect,
    )

    k8s_backend = K8sBackend[AuthenticationObject](
        template_dirs=TEMPLATES,
        hooks=make_hooks(mock_api_client),
    )

    with expectation:
        await k8s_backend.remove_check(
            AuthenticationObject(test_auth),
            CheckId(check_id_1),
        )

        mock_batch_v1_api.assert_called_once()
        mock_batch_v1_api.return_value.delete_namespaced_cron_job.assert_called_once()
        call_kwargs = (
            mock_batch_v1_api.return_value.delete_namespaced_cron_job.call_args.kwargs
        )
        assert call_kwargs["name"] == check_id_1
        assert call_kwargs["namespace"] == NAMESPACE


@pytest.mark.parametrize(
    ("check_ids,side_effect,expectation,expected"),
    [
        (
            None,
            None,
            contextlib.nullcontext(),
            3,
        ),
        (
            [check_id_1],
            None,
            contextlib.nullcontext(),
            1,
        ),
        (
            [check_id_1, check_id_2],
            None,
            contextlib.nullcontext(),
            2,
        ),
        (
            [check_id_1, check_id_2, check_id_3],
            None,
            contextlib.nullcontext(),
            3,
        ),
        (
            [check_id_4],
            None,
            contextlib.nullcontext(),
            0,
        ),
        (
            [check_id_1, check_id_4],
            None,
            contextlib.nullcontext(),
            1,
        ),
        (
            [check_id_1, check_id_2, check_id_4],
            None,
            contextlib.nullcontext(),
            2,
        ),
        (
            None,
            ApiException,
            pytest.raises(ApiException),
            None,
        ),
        (
            None,
            aiohttp.ClientConnectionError,
            pytest.raises(CheckConnectionError),
            None,
        ),
        (
            None,
            Exception,
            pytest.raises(Exception),
            None,
        ),
    ],
)
@patch("test_k8s_backend.client.BatchV1Api")
async def test_get_checks(
    mock_batch_v1_api: Mock,
    check_ids: list[CheckId],
    side_effect: Exception | None,
    expectation: contextlib.AbstractContextManager,
    expected: int | None,
    mock_api_client: Mock,
) -> None:
    mock_batch_v1_api.return_value.list_namespaced_cron_job = AsyncMock(
        side_effect=side_effect,
        return_value=V1JobList(items=[cronjob_1, cronjob_2, cronjob_3]),
    )

    k8s_backend = K8sBackend[AuthenticationObject](
        template_dirs=TEMPLATES,
        hooks=make_hooks(mock_api_client),
    )

    with expectation:
        check_async_iterator = k8s_backend.get_checks(
            AuthenticationObject(test_auth),
            check_ids,
        )
        check_list = []
        async for check in check_async_iterator:
            check_list.append(check)

        assert len(check_list) == expected

        mock_batch_v1_api.assert_called_once()
        mock_batch_v1_api.return_value.list_namespaced_cron_job.assert_called_once()
        call_kwargs = (
            mock_batch_v1_api.return_value.list_namespaced_cron_job.call_args.kwargs
        )
        assert call_kwargs["namespace"] == NAMESPACE


@pytest.mark.parametrize(
    ("side_effect_read, side_effect_create, expectation"),
    [
        (
            None,
            None,
            contextlib.nullcontext(),
        ),
        (
            ApiException(status=404),
            None,
            pytest.raises(CheckIdError),
        ),
        (
            ApiException(),
            None,
            pytest.raises(ApiException),
        ),
        (
            aiohttp.ClientConnectionError(),
            None,
            pytest.raises(CheckConnectionError),
        ),
        (
            Exception(),
            None,
            pytest.raises(Exception),
        ),
        (
            None,
            ApiException(status=404),
            pytest.raises(CheckIdError),
        ),
        (
            None,
            ApiException(),
            pytest.raises(ApiException),
        ),
        (
            None,
            aiohttp.ClientConnectionError(),
            pytest.raises(CheckConnectionError),
        ),
        (
            None,
            Exception(),
            pytest.raises(Exception),
        ),
    ],
)
@patch("test_k8s_backend.client.BatchV1Api")
async def test_run_check(
    mock_batch_v1_api: Mock,
    side_effect_read: Exception | None,
    side_effect_create: Exception | None,
    expectation: contextlib.AbstractContextManager,
    mock_api_client: Mock,
) -> None:
    mock_batch_v1_api.return_value.read_namespaced_cron_job = AsyncMock(
        side_effect=side_effect_read,
        return_value=cronjob_1,
    )
    mock_batch_v1_api.return_value.create_namespaced_job = AsyncMock(
        side_effect=side_effect_create,
    )

    k8s_backend = K8sBackend[AuthenticationObject](
        template_dirs=TEMPLATES,
        hooks=make_hooks(mock_api_client),
    )

    with expectation:
        await k8s_backend.run_check(
            AuthenticationObject(test_auth),
            CheckId(check_id_1),
        )

        mock_batch_v1_api.assert_called_once()
        mock_batch_v1_api.return_value.read_namespaced_cron_job.assert_called_once()
        call_kwargs_read = (
            mock_batch_v1_api.return_value.read_namespaced_cron_job.call_args.kwargs
        )
        assert call_kwargs_read["name"] == check_id_1
        assert call_kwargs_read["namespace"] == NAMESPACE
        mock_batch_v1_api.return_value.create_namespaced_job.assert_called_once()
        call_kwargs_create = (
            mock_batch_v1_api.return_value.create_namespaced_job.call_args.kwargs
        )
        assert call_kwargs_create["namespace"] == NAMESPACE
        assert (
            call_kwargs_create["body"].metadata.owner_references[0].name == check_id_1
        )
        assert (
            call_kwargs_create["body"].metadata.owner_references[0].uid == check_uuid_1
        )
